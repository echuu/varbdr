source("C:/Users/chuu/varbdr/code/globals.R")
setwd(HOME_DIR)
source(DP_BDR)
source(DENSITY)
setwd("C:/Users/chuu/varbdr/code/cpp_code")
source("C:/Users/chuu/varbdr/code/cov_dep/misc.R")
source("debug_funcs.R")
N = 100
K = 3
D = 1
synth_data_1d = r_dpmix2(N)
y      = synth_data_1d$y
X      = synth_data_1d$X
intercept = FALSE
max_iter = 5000
sourceCpp("getVarParams.cpp")
theta_cpp = testConstructor(y, X, N, D, K, intercept, max_iter)
str(theta_cpp)
source(paste(COV_DEP,  INIT_PRIORS,     sep = '/'))
source(paste(COV_DEP,  INIT_VAR_PARAMS, sep = '/'))
source(paste(COV_DEP,  E_STEP,          sep = '/'))
source(paste(COV_DEP,  M_STEP,          sep = '/'))
source(paste(COV_DEP,  ELBO,            sep = '/'))
source(paste(COV_DEP,  MISC_FUNCS,      sep = '/'))
source(paste(HOME_DIR, DENSITY,         sep = '/'))
m_0 = c(colMeans(X))                         # normal params
Lambda_0 = diag(rep(1, ncol(X)))
a_0 = 1
b_0 = 1                             # gamma params
g_0 = 0
Sigma_0 = diag(rep(1, ncol(X)))
tol = 1e-3
VERBOSE = FALSE
# use c++ initializations for these variational parameters
mu_k = theta_cpp$mu_k
m_k  = theta_cpp$m_k
prior = initPriors(y, X, K, m_0, Lambda_0, a_0, b_0, g_0, Sigma_0,
max_iter, tol, VERBOSE)
theta = initVarParams_0(y, X, N, D, K, intercept, max_iter, m_k, mu_k)
str(theta)
theta = mStep(theta, prior)
checkEqual(theta_cpp$alpha, theta$alpha)
sum(theta_cpp$xi != theta$xi)
head(theta_cpp$xi)
head(theta_xi)
head(theta$xi)
head(theta$alpha)
head(theta_cpp$alpha)
slow_func = function(lambda, X, X_mu, Qk, xi) {
N = nrow(lambda)
K = ncol(lambda)
phi = numeric(N)
for (n in 1:N) {
alpha[n] = 1 / sum(lambda[n,]) *
(0.5 * (0.5 * K - 1) + crossprod(X_mu[n,], lambda[n,]))
for (k in 1:K) {
xQx[k] = sum(lambda[,k]) * crossprod(X[n,], Qk %*% X[n,])
}
xi[n,] = sqrt((X_mu[n,] - alpha[n])^2 + xQx)
}
lambda = lambda_xi(xi)
# (0.4) compute phi (function of alpha, xi) --------------------------------
for (n in 1:N) {
phi[n] = sum((X_mu[n,] - alpha[n] - xi[n,]) / 2 +
log(1 + exp(xi[n,])))
} # end for() update for phi
return(list(alpha = alpha, xQx = xQx, xi = xi, phi = phi, lambda = lambda))
}
N = 100
K = 3
D = 1
synth_data_1d = r_dpmix2(N)
y      = synth_data_1d$y
X      = synth_data_1d$X
mu = matrix(rnorm(D * K), D, K)                  # (D x K)
X_mu = X %*% mu                                  # (N x K)
xi = matrix(1, N, K)                             # (N x K)
lambda = lambda_xi(xi)                           # (N x K)
Qk = rbeta(D, 1, 1)                              # (D x D)
sourceCpp("fast_functions.cpp")
res = slow_func(lambda, X, X_mu, Qk, xi)        # slower version of the m-step
lambda
res = slow_func(lambda, X, X_mu, Qk, xi)        # slower version of the m-step
slow_func = function(lambda, X, X_mu, Qk, xi) {
N = nrow(lambda)
K = ncol(lambda)
alpha = numeric(N)
phi = numeric(N)
xQx = numeric(K)
for (n in 1:N) {
alpha[n] = 1 / sum(lambda[n,]) *
(0.5 * (0.5 * K - 1) + crossprod(X_mu[n,], lambda[n,]))
for (k in 1:K) {
xQx[k] = sum(lambda[,k]) * crossprod(X[n,], Qk %*% X[n,])
}
xi[n,] = sqrt((X_mu[n,] - alpha[n])^2 + xQx)
}
lambda = lambda_xi(xi)
# (0.4) compute phi (function of alpha, xi) --------------------------------
for (n in 1:N) {
phi[n] = sum((X_mu[n,] - alpha[n] - xi[n,]) / 2 +
log(1 + exp(xi[n,])))
} # end for() update for phi
return(list(alpha = alpha, xQx = xQx, xi = xi, phi = phi, lambda = lambda))
}
res = slow_func(lambda, X, X_mu, Qk, xi)        # slower version of the m-step
res$alpha
res$xi
res$phi
res$lambda
res_fast = mainFunc(lambda, X, X_mu, Qk, xi)    # build this to be the m-step
head(res_fast$alpha)
head(res$alpha)
head(res$xi)
head(res_fast$xi)
sourceCpp("getVarParams.cpp")
theta_cpp = testConstructor(y, X, N, D, K, intercept, max_iter)
str(theta_cpp)
theta$xi
head(theta$xi)
head(theta_cpp$xi)
sourceCpp("getVarParams.cpp")
sourceCpp("getVarParams.cpp")
theta_cpp = testConstructor(y, X, N, D, K, intercept, max_iter)
str(theta_cpp)
m_0 = c(colMeans(X))                         # normal params
Lambda_0 = diag(rep(1, ncol(X)))
a_0 = 1
b_0 = 1                             # gamma params
g_0 = 0
Sigma_0 = diag(rep(1, ncol(X)))
tol = 1e-3
VERBOSE = FALSE
# use c++ initializations for these variational parameters
mu_k = theta_cpp$mu_k
m_k  = theta_cpp$m_k
prior = initPriors(y, X, K, m_0, Lambda_0, a_0, b_0, g_0, Sigma_0,
max_iter, tol, VERBOSE)
theta = initVarParams_0(y, X, N, D, K, intercept, max_iter, m_k, mu_k)
theta = mStep(theta, prior)
checkEqual(theta_cpp$alpha, theta$alpha)
sum(theta_cpp$xi != theta$xi)
head(theta_cpp$xi)
head(theta$xi)
source(paste(COV_DEP,  INIT_PRIORS,     sep = '/'))
source(paste(COV_DEP,  INIT_VAR_PARAMS, sep = '/'))
source(paste(COV_DEP,  E_STEP,          sep = '/'))
source(paste(COV_DEP,  M_STEP,          sep = '/'))
source(paste(COV_DEP,  ELBO,            sep = '/'))
source(paste(COV_DEP,  MISC_FUNCS,      sep = '/'))
source(paste(HOME_DIR, DENSITY,         sep = '/'))
m_0 = c(colMeans(X))                         # normal params
Lambda_0 = diag(rep(1, ncol(X)))
a_0 = 1
b_0 = 1                             # gamma params
g_0 = 0
Sigma_0 = diag(rep(1, ncol(X)))
tol = 1e-3
VERBOSE = FALSE
# use c++ initializations for these variational parameters
mu_k = theta_cpp$mu_k
m_k  = theta_cpp$m_k
prior = initPriors(y, X, K, m_0, Lambda_0, a_0, b_0, g_0, Sigma_0,
max_iter, tol, VERBOSE)
theta = initVarParams_0(y, X, N, D, K, intercept, max_iter, m_k, mu_k)
theta = mStep(theta, prior)
head(theta$xi)
heat(theta_cpp$xi)
head(theta_cpp$xi)
checkEqual(theta_cpp$alpha, theta$alpha)
sum(theta_cpp$xi != theta$xi)
sum(theta_cpp$phi != theta$phi)
sum(theta_cpp$lambda != theta$lambda)
head(theta_cpp$phi)
head(theta$phi)
theta_cpp$lambda[theta_cpp$lambda != theta$lambda]
theta_cpp$lambda != theta$lambda
sum(theta_cpp$phi != theta$phi)
I_D
theta_cpp$phi
theta_cpp$phi == theta$phi
theta_cpp$phi[theta_cpp$phi == theta$phi]
theta_cpp$phi[theta_cpp$phi != theta$phi]
theta$phi[theta_cpp$phi != theta$phi]
all.equal(theta$phi, theta_cpp$phi)
all.equal(theta$xi, theta_cpp$xi)
all.equal(theta$lambda, theta_cpp$lambda)
all.equal(theta_cpp$alpha, theta$alpha)
sourceCpp("getVarParams.cpp")
sourceCpp("getVarParams.cpp")
theta_cpp = testConstructor(y, X, N, D, K, intercept, max_iter)
str(theta_cpp)
m_0 = c(colMeans(X))                         # normal params
Lambda_0 = diag(rep(1, ncol(X)))
a_0 = 1
b_0 = 1                             # gamma params
g_0 = 0
Sigma_0 = diag(rep(1, ncol(X)))
tol = 1e-3
VERBOSE = FALSE
# use c++ initializations for these variational parameters
mu_k = theta_cpp$mu_k
m_k  = theta_cpp$m_k
prior = initPriors(y, X, K, m_0, Lambda_0, a_0, b_0, g_0, Sigma_0,
max_iter, tol, VERBOSE)
theta = initVarParams_0(y, X, N, D, K, intercept, max_iter, m_k, mu_k)
theta = mStep(theta, prior)
all.equal(theta_cpp$alpha, theta$alpha)
all.equal(theta$xi, theta_cpp$xi)
all.equal(theta$phi, theta_cpp$phi)
all.equal(theta$lambda, theta_cpp$lambda)
