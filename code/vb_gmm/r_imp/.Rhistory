}
i=3
## Variational E-Step
theta = eStep(N, D, K, X, theta)
theta$r_nk
## Variational M-Step
theta = mStep(N, K, D, X, theta, alpha_0, beta_0, nu_0, W_0_inv, m_0)
# Compute the Variational Lower Bound ----------------------------------
L[i] = elbo(D, K, theta, alpha_0, m_0, beta_0, W_0, W_0_inv, nu_0)
### check convergence -- if VERBOSE, then ELBO printed -----------------
if (checkELBO(VERBOSE, i, max_iter, L, epsilon_conv)) {
break
}
X
K = 3
alpha_0 = 1e-5
m_0 = c(colMeans(X))
beta_0 = 1
nu_0 = NCOL(X) + 50
W_0 = diag(100, NCOL(X))
max_iter = 1001
epsilon_conv = 1e-4
is_animation = TRUE
VERBOSE = TRUE
# Run vb-gmm model model
vb_gmm_model = vb_gmm(X = X, K = K, alpha_0 = 1e-5, max_iter = 1001,
is_animation = TRUE, VERBOSE = TRUE)
theta$_r_nk
theta$r_nk
X = as.matrix(X)         # N X D design matrix of covariates
D = NCOL(X)              # Number of features
N = NROW(X)              # Number of observations
L = rep(-Inf, max_iter)  # Store the variational lower bounds
W_0_inv = solve(W_0)     # Compute W_0^{-1} (used in updates for W_k)
# initialize storage matrices/vectors for var. parameters: z_nk, pi_k
r_nk      = log_r_nk = log_rho_nk = matrix(0, nrow = N, ncol = K) # N x K
x_bar_k   = matrix(0, nrow = D, ncol = K)         # (D x K) Bishop 10.52
# S_k is a K-dim array that stores (D x D) (covariance) matrices
S_k       = W_k = array(0, c(D, D, K))           # (D x D) Bishop 10.53
log_pi    = log_Lambda = rep(0, K)
# initialize variational parameters: for mu_k, lambda_k, alpha_k, pi_k
m_k       = t(kmeans(X, K, nstart = 25)$centers)  # Mean of Gaussian
m_k       = matrix(0, D, K)
beta_k    = rep(beta_0, K)                        # Scale of precision mat
nu_k      = rep(nu_0, K)                          # Degrees of freedom
alpha     = rep(alpha_0, K)                       # Dirichlet parameter
# E[log(pi)] -- (K x 1) ---> needed for r_nk update
log_pi    = digamma(alpha) - digamma(sum(alpha))
for (k in 1:K) {
W_k[,,k] =  W_0  # Scale matrix for Wishart
# E [ log(det(Lambda_k)) ] ---> needed for r_nk update
log_Lambda[k] = sum(digamma((nu_k[k] + 1 - c(1:D)) / 2)) +
D * log(2) + log(det(W_k[ , , k]))
}
theta = initVarParams(K, log_Lambda, log_pi, N_k, S_k, x_bar_k,
m_k, W_k, nu_k, beta_k, alpha, r_nk, log_r_nk)
theta$m_k
## Variational E-Step
theta = eStep(N, D, K, X, theta)
theta$r_nk
## Variational M-Step
theta = mStep(N, K, D, X, theta, alpha_0, beta_0, nu_0, W_0_inv, m_0)
# Compute the Variational Lower Bound ----------------------------------
L[i] = elbo(D, K, theta, alpha_0, m_0, beta_0, W_0, W_0_inv, nu_0)
### check convergence -- if VERBOSE, then ELBO printed -----------------
if (checkELBO(VERBOSE, i, max_iter, L, epsilon_conv)) {
break
}
# Run vb-gmm model model
vb_gmm_model = vb_gmm(X = X, K = K, alpha_0 = 1e-5, max_iter = 1001,
is_animation = TRUE, VERBOSE = TRUE)
X
K = 3
alpha_0 = 1e-5
m_0 = c(colMeans(X))
beta_0 = 1
nu_0 = NCOL(X) + 50
W_0 = diag(100, NCOL(X))
max_iter = 1001
epsilon_conv = 1e-4
is_animation = TRUE
VERBOSE = TRUE
## animation details -------------------------------------------------------
if (is_animation) {
# Variables needed for plotting
xgrid = seq(from = min(X[,1]) - 2, to = max(X[,1]) + 2, length.out = 80)
ygrid = seq(from = min(X[,2]) - 8, to = max(X[,2]) + 2, length.out = 80)
dt = data.table(expand.grid(x = xgrid, y = ygrid))
}
dt_all = data.table(x = numeric(), y = numeric(), z = numeric(),
iter = numeric())
## animation details -------------------------------------------------------
X = as.matrix(X)         # N X D design matrix of covariates
D = NCOL(X)              # Number of features
N = NROW(X)              # Number of observations
L = rep(-Inf, max_iter)  # Store the variational lower bounds
W_0_inv = solve(W_0)     # Compute W_0^{-1} (used in updates for W_k)
# initialize storage matrices/vectors for var. parameters: z_nk, pi_k
r_nk      = log_r_nk = log_rho_nk = matrix(0, nrow = N, ncol = K) # N x K
x_bar_k   = matrix(0, nrow = D, ncol = K)         # (D x K) Bishop 10.52
# S_k is a K-dim array that stores (D x D) (covariance) matrices
S_k       = W_k = array(0, c(D, D, K))           # (D x D) Bishop 10.53
log_pi    = log_Lambda = rep(0, K)
# initialize variational parameters: for mu_k, lambda_k, alpha_k, pi_k
m_k       = t(kmeans(X, K, nstart = 25)$centers)  # Mean of Gaussian
m_k       = matrix(0, D, K)
beta_k    = rep(beta_0, K)                        # Scale of precision mat
nu_k      = rep(nu_0, K)                          # Degrees of freedom
alpha     = rep(alpha_0, K)                       # Dirichlet parameter
# E[log(pi)] -- (K x 1) ---> needed for r_nk update
log_pi    = digamma(alpha) - digamma(sum(alpha))
for (k in 1:K) {
W_k[,,k] =  W_0  # Scale matrix for Wishart
# E [ log(det(Lambda_k)) ] ---> needed for r_nk update
log_Lambda[k] = sum(digamma((nu_k[k] + 1 - c(1:D)) / 2)) +
D * log(2) + log(det(W_k[ , , k]))
}
#### -----------------------------------------------------------------------
## animation details -------------------------------------------------------
if (is_animation) { # Create animation for initial assignments
my_z = mixture_pdf_t(model = list(m = m_k, W = W_k, beta = beta_k,
nu = nu_k, alpha = rep(1/K, K)),
data = dt)
dt_all = rbind(dt_all, dt[, z := my_z] %>% .[, iter := 0])
}
## animation details -------------------------------------------------------
theta = initVarParams(K, log_Lambda, log_pi, N_k, S_k, x_bar_k,
m_k, W_k, nu_k, beta_k, alpha, r_nk, log_r_nk)
i = 2
## Variational E-Step
theta = eStep(N, D, K, X, theta)
## Variational M-Step
theta = mStep(N, K, D, X, theta, alpha_0, beta_0, nu_0, W_0_inv, m_0)
# Compute the Variational Lower Bound ----------------------------------
L[i] = elbo(D, K, theta, alpha_0, m_0, beta_0, W_0, W_0_inv, nu_0)
## animation details ---------------------------------------------------
# Evaluate mixture density for plotting
if (is_animation) {
if ( (i - 1) %% 5 == 0 | i < 10) {
my_z = mixture_pdf_t(model = list(m = theta$m_k, W = theta$W_k,
beta = theta$beta_k,
nu = theta$nu_k,
alpha = theta$alpha),
data = dt)
dt_all = rbind(dt_all, dt[, z := my_z] %>% .[, iter := i - 1])
}
}
### check convergence -- if VERBOSE, then ELBO printed -----------------
if (checkELBO(VERBOSE, i, max_iter, L, epsilon_conv)) {
break
}
alph_0
alpha_0
source("densityCalculations.R")
source("vb_calcs.R")
source("misc.R")
K = 3
alpha_0 = 1e-5
m_0 = c(colMeans(X))
beta_0 = 1
nu_0 = NCOL(X) + 50
W_0 = diag(100, NCOL(X))
max_iter = 1001
epsilon_conv = 1e-4
is_animation = TRUE
VERBOSE = TRUE
## animation details -------------------------------------------------------
if (is_animation) {
# Variables needed for plotting
xgrid = seq(from = min(X[,1]) - 2, to = max(X[,1]) + 2, length.out = 80)
ygrid = seq(from = min(X[,2]) - 8, to = max(X[,2]) + 2, length.out = 80)
dt = data.table(expand.grid(x = xgrid, y = ygrid))
}
dt_all = data.table(x = numeric(), y = numeric(), z = numeric(),
iter = numeric())
## animation details -------------------------------------------------------
X = as.matrix(X)         # N X D design matrix of covariates
D = NCOL(X)              # Number of features
N = NROW(X)              # Number of observations
L = rep(-Inf, max_iter)  # Store the variational lower bounds
W_0_inv = solve(W_0)     # Compute W_0^{-1} (used in updates for W_k)
# initialize storage matrices/vectors for var. parameters: z_nk, pi_k
r_nk      = log_r_nk = log_rho_nk = matrix(0, nrow = N, ncol = K) # N x K
x_bar_k   = matrix(0, nrow = D, ncol = K)         # (D x K) Bishop 10.52
# S_k is a K-dim array that stores (D x D) (covariance) matrices
S_k       = W_k = array(0, c(D, D, K))           # (D x D) Bishop 10.53
log_pi    = log_Lambda = rep(0, K)
# initialize variational parameters: for mu_k, lambda_k, alpha_k, pi_k
m_k       = t(kmeans(X, K, nstart = 25)$centers)  # Mean of Gaussian
m_k       = matrix(0, D, K)
beta_k    = rep(beta_0, K)                        # Scale of precision mat
nu_k      = rep(nu_0, K)                          # Degrees of freedom
alpha     = rep(alpha_0, K)                       # Dirichlet parameter
# E[log(pi)] -- (K x 1) ---> needed for r_nk update
log_pi    = digamma(alpha) - digamma(sum(alpha))
for (k in 1:K) {
W_k[,,k] =  W_0  # Scale matrix for Wishart
# E [ log(det(Lambda_k)) ] ---> needed for r_nk update
log_Lambda[k] = sum(digamma((nu_k[k] + 1 - c(1:D)) / 2)) +
D * log(2) + log(det(W_k[ , , k]))
}
#### -----------------------------------------------------------------------
## animation details -------------------------------------------------------
if (is_animation) { # Create animation for initial assignments
my_z = mixture_pdf_t(model = list(m = m_k, W = W_k, beta = beta_k,
nu = nu_k, alpha = rep(1/K, K)),
data = dt)
dt_all = rbind(dt_all, dt[, z := my_z] %>% .[, iter := 0])
}
## animation details -------------------------------------------------------
theta = initVarParams(K, log_Lambda, log_pi, N_k, S_k, x_bar_k,
m_k, W_k, nu_k, beta_k, alpha, r_nk, log_r_nk)
i
## Variational E-Step
theta = eStep(N, D, K, X, theta)
## Variational M-Step
theta = mStep(N, K, D, X, theta, alpha_0, beta_0, nu_0, W_0_inv, m_0)
theta$r_nk
# Compute the Variational Lower Bound ----------------------------------
L[i] = elbo(D, K, theta, alpha_0, m_0, beta_0, W_0, W_0_inv, nu_0)
## animation details ---------------------------------------------------
# Evaluate mixture density for plotting
if (is_animation) {
if ( (i - 1) %% 5 == 0 | i < 10) {
my_z = mixture_pdf_t(model = list(m = theta$m_k, W = theta$W_k,
beta = theta$beta_k,
nu = theta$nu_k,
alpha = theta$alpha),
data = dt)
dt_all = rbind(dt_all, dt[, z := my_z] %>% .[, iter := i - 1])
}
}
### check convergence -- if VERBOSE, then ELBO printed -----------------
if (checkELBO(VERBOSE, i, max_iter, L, epsilon_conv)) {
break
}
i - 3
i = 3
## Variational E-Step
theta = eStep(N, D, K, X, theta)
## Variational M-Step
theta = mStep(N, K, D, X, theta, alpha_0, beta_0, nu_0, W_0_inv, m_0)
# Compute the Variational Lower Bound ----------------------------------
L[i] = elbo(D, K, theta, alpha_0, m_0, beta_0, W_0, W_0_inv, nu_0)
theta$r_nk
### check convergence -- if VERBOSE, then ELBO printed -----------------
if (checkELBO(VERBOSE, i, max_iter, L, epsilon_conv)) {
break
}
K = 3
alpha_0 = 1e-5
m_0 = c(colMeans(X))
beta_0 = 1
nu_0 = NCOL(X) + 50
W_0 = diag(100, NCOL(X))
max_iter = 1001
epsilon_conv = 1e-4
is_animation = TRUE
VERBOSE = TRUE
## animation details -------------------------------------------------------
if (is_animation) {
# Variables needed for plotting
xgrid = seq(from = min(X[,1]) - 2, to = max(X[,1]) + 2, length.out = 80)
ygrid = seq(from = min(X[,2]) - 8, to = max(X[,2]) + 2, length.out = 80)
dt = data.table(expand.grid(x = xgrid, y = ygrid))
}
dt_all = data.table(x = numeric(), y = numeric(), z = numeric(),
iter = numeric())
## animation details -------------------------------------------------------
X = as.matrix(X)         # N X D design matrix of covariates
D = NCOL(X)              # Number of features
N = NROW(X)              # Number of observations
L = rep(-Inf, max_iter)  # Store the variational lower bounds
W_0_inv = solve(W_0)     # Compute W_0^{-1} (used in updates for W_k)
# initialize storage matrices/vectors for var. parameters: z_nk, pi_k
r_nk      = log_r_nk = log_rho_nk = matrix(0, nrow = N, ncol = K) # N x K
x_bar_k   = matrix(0, nrow = D, ncol = K)         # (D x K) Bishop 10.52
# S_k is a K-dim array that stores (D x D) (covariance) matrices
S_k       = W_k = array(0, c(D, D, K))           # (D x D) Bishop 10.53
log_pi    = log_Lambda = rep(0, K)
# initialize variational parameters: for mu_k, lambda_k, alpha_k, pi_k
m_k       = t(kmeans(X, K, nstart = 25)$centers)  # Mean of Gaussian
m_k       = matrix(0, D, K)
beta_k    = rep(beta_0, K)                        # Scale of precision mat
nu_k      = rep(nu_0, K)                          # Degrees of freedom
alpha     = rep(alpha_0, K)                       # Dirichlet parameter
# E[log(pi)] -- (K x 1) ---> needed for r_nk update
log_pi    = digamma(alpha) - digamma(sum(alpha))
for (k in 1:K) {
W_k[,,k] =  W_0  # Scale matrix for Wishart
# E [ log(det(Lambda_k)) ] ---> needed for r_nk update
log_Lambda[k] = sum(digamma((nu_k[k] + 1 - c(1:D)) / 2)) +
D * log(2) + log(det(W_k[ , , k]))
}
#### -----------------------------------------------------------------------
## animation details -------------------------------------------------------
if (is_animation) { # Create animation for initial assignments
my_z = mixture_pdf_t(model = list(m = m_k, W = W_k, beta = beta_k,
nu = nu_k, alpha = rep(1/K, K)),
data = dt)
dt_all = rbind(dt_all, dt[, z := my_z] %>% .[, iter := 0])
}
## animation details -------------------------------------------------------
theta = initVarParams(K, log_Lambda, log_pi, N_k, S_k, x_bar_k,
m_k, W_k, nu_k, beta_k, alpha, r_nk, log_r_nk)
theta$r_nk
i = 2
## Variational E-Step
theta = eStep(N, D, K, X, theta)
## Variational M-Step
theta = mStep(N, K, D, X, theta, alpha_0, beta_0, nu_0, W_0_inv, m_0)
theta$r_nk
# Compute the Variational Lower Bound ----------------------------------
L[i] = elbo(D, K, theta, alpha_0, m_0, beta_0, W_0, W_0_inv, nu_0)
## animation details ---------------------------------------------------
# Evaluate mixture density for plotting
if (is_animation) {
if ( (i - 1) %% 5 == 0 | i < 10) {
my_z = mixture_pdf_t(model = list(m = theta$m_k, W = theta$W_k,
beta = theta$beta_k,
nu = theta$nu_k,
alpha = theta$alpha),
data = dt)
dt_all = rbind(dt_all, dt[, z := my_z] %>% .[, iter := i - 1])
}
}
### check convergence -- if VERBOSE, then ELBO printed -----------------
if (checkELBO(VERBOSE, i, max_iter, L, epsilon_conv)) {
break
}
i = 3
## Variational E-Step
theta = eStep(N, D, K, X, theta)
## Variational M-Step
theta = mStep(N, K, D, X, theta, alpha_0, beta_0, nu_0, W_0_inv, m_0)
# Compute the Variational Lower Bound ----------------------------------
L[i] = elbo(D, K, theta, alpha_0, m_0, beta_0, W_0, W_0_inv, nu_0)
### check convergence -- if VERBOSE, then ELBO printed -----------------
if (checkELBO(VERBOSE, i, max_iter, L, epsilon_conv)) {
break
}
# Run vb-gmm model model
vb_gmm_model = vb_gmm(X = X, K = K, alpha_0 = 1e-5, max_iter = 1001,
is_animation = TRUE, VERBOSE = TRUE)
K = 3
alpha_0 = 1e-5
m_0 = c(colMeans(X))
beta_0 = 1
nu_0 = NCOL(X) + 50
W_0 = diag(100, NCOL(X))
max_iter = 500
epsilon_conv = 1e-4
is_animation = TRUE
VERBOSE = TRUE
# Run vb-gmm model model
vb_gmm_model = vb_gmm(X = X, K = K, alpha_0 = 1e-5, max_iter = 1001,
is_animation = TRUE, VERBOSE = TRUE)
source("displayResults.R")
source("gmVB_0.R")
# View(faithful) # 272 x 2 : duration of eruption, waiting time b/w eruptions
# X = as.matrix(faithful[1:10,])
# X = as.matrix(faithful)
K = 25        # Number of clusters
K = 3
alpha_0 = 1e-5
m_0 = c(colMeans(X))
beta_0 = 1
nu_0 = NCOL(X) + 50
W_0 = diag(100, NCOL(X))
max_iter = 500
epsilon_conv = 1e-4
is_animation = TRUE
VERBOSE = TRUE
# Run vb-gmm model model
vb_gmm_model = vb_gmm(X = X, K = K, alpha_0 = 1e-5, max_iter = 1001,
is_animation = TRUE, VERBOSE = TRUE)
source("displayResults.R")
source("gmVB_0.R")
# View(faithful) # 272 x 2 : duration of eruption, waiting time b/w eruptions
# X = as.matrix(faithful[1:10,])
# X = as.matrix(faithful)
K = 25        # Number of clusters
K = 3
alpha_0 = 1e-5
m_0 = c(colMeans(X))
beta_0 = 1
nu_0 = NCOL(X) + 50
W_0 = diag(100, NCOL(X))
max_iter = 500
epsilon_conv = 1e-4
is_animation = TRUE
VERBOSE = TRUE
# Run vb-gmm model model
vb_gmm_model = vb_gmm(X = X, K = K, alpha_0 = 1e-5, max_iter = 1001,
is_animation = TRUE, VERBOSE = TRUE)
X = as.matrix(faithful)
K = 25        # Number of clusters
K = 3
alpha_0 = 1e-5
m_0 = c(colMeans(X))
beta_0 = 1
nu_0 = NCOL(X) + 50
W_0 = diag(100, NCOL(X))
max_iter = 500
epsilon_conv = 1e-4
is_animation = TRUE
VERBOSE = TRUE
# Run vb-gmm model model
vb_gmm_model = vb_gmm(X = X, K = K, alpha_0 = 1e-5, max_iter = 1001,
is_animation = TRUE, VERBOSE = TRUE)
# setwd("/home/eric/varbdr/code/vb_gmm/r_imp")
source("displayResults.R")
source("gmVB_0.R")
X = as.matrix(faithful)
K = 25        # Number of clusters
K = 3
alpha_0 = 1e-5
m_0 = c(colMeans(X))
beta_0 = 1
nu_0 = NCOL(X) + 50
W_0 = diag(100, NCOL(X))
max_iter = 500
epsilon_conv = 1e-4
is_animation = TRUE
VERBOSE = TRUE
# Run vb-gmm model model
vb_gmm_model = vb_gmm(X = X, K = K, alpha_0 = 1e-5, max_iter = 1001,
is_animation = TRUE, VERBOSE = TRUE)
source("gmVB_0.R")
# Run vb-gmm model model
source("gmVB_0.R")
vb_gmm_model = vb_gmm(X = X, K = K, alpha_0 = 1e-5, max_iter = 1001,
is_animation = TRUE, VERBOSE = TRUE)
c(colMeans(X))
t(kmeans(X, K, nstart = 25)$centers)
source("gmVB_0.R")
# testResults.R
run = function() {
set.seed(12)
# setwd to source file location
setwd("C:/Users/chuu/varbdr/code/vb_gmm/r_imp")
# setwd("/home/eric/varbdr/code/vb_gmm/r_imp")
source("displayResults.R")
source("gmVB_0.R")
# View(faithful) # 272 x 2 : duration of eruption, waiting time b/w eruptions
# X = as.matrix(faithful[1:10,])
X = as.matrix(faithful)
K = 25        # Number of clusters
K = 3
alpha_0 = 1e-5
m_0 = c(colMeans(X))
# m_0 = rep(0, )
beta_0 = 1
nu_0 = NCOL(X) + 50
W_0 = diag(100, NCOL(X))
max_iter = 500
epsilon_conv = 1e-4
is_animation = TRUE
VERBOSE = TRUE
# Run vb-gmm model model
source("gmVB_0.R")
vb_gmm_model = vb_gmm(X = X, K = K, alpha_0 = 1e-5, max_iter = 1001,
is_animation = TRUE, VERBOSE = TRUE)
data.grid = expand.grid(x = seq(from = min(X[,1]) - 2,
to = max(X[,1]) + 2, length.out = 100),
y = seq(from = min(X[,2]) - 8,
to = max(X[,2]) + 2, length.out = 100))
# generate from predictive desntiy
q.samp = cbind(data.grid, z = mixture_pdf_t(vb_gmm_model,data.grid))
ggplot() +
geom_point(data = data.frame(X), mapping = aes(eruptions, waiting)) +
geom_contour(data = q.samp,
mapping = aes(x = x,y = y, z = z,
colour = ..level..), binwidth = 0.001) +
gg_theme()
}
run()
X = as.matrix(X)         # N X D design matrix of covariates
D = NCOL(X)              # Number of features
N = NROW(X)              # Number of observations
L = rep(-Inf, max_iter)  # Store the variational lower bounds
W_0_inv = solve(W_0)     # Compute W_0^{-1} (used in updates for W_k)
# initialize storage matrices/vectors for var. parameters: z_nk, pi_k
r_nk      = log_r_nk = log_rho_nk = matrix(0, nrow = N, ncol = K) # N x K
x_bar_k   = matrix(0, nrow = D, ncol = K)         # (D x K) Bishop 10.52
# S_k is a K-dim array that stores (D x D) (covariance) matrices
S_k       = W_k = array(0, c(D, D, K))           # (D x D) Bishop 10.53
log_pi    = log_Lambda = rep(0, K)
# initialize variational parameters: for mu_k, lambda_k, alpha_k, pi_k
m_k       = t(kmeans(X, K, nstart = 25)$centers)  # Mean of Gaussian
# m_k       = matrix(0, D, K) ## this line causing issues in convergence
beta_k    = rep(beta_0, K)                        # Scale of precision mat
nu_k      = rep(nu_0, K)                          # Degrees of freedom
alpha     = rep(alpha_0, K)                       # Dirichlet parameter
m_k
y
kmeans(y, K, nstart = 25)
test  =kmeans(y, K, nstart = 25)
mean(y[test$cluster == 3] )
test$centers
mean(y[test$cluster == 1] )
mean(y[test$cluster == 3] )
mean(y[test$cluster == 2] )
# Run vb-gmm model model
source("gmVB_0.R")
vb_gmm_model = vb_gmm(X = X, K = K, alpha_0 = 1e-5, max_iter = 1001,
is_animation = TRUE, VERBOSE = TRUE)
q.sam
q.samp_
q.samp
head(q.samp)
data.grid
